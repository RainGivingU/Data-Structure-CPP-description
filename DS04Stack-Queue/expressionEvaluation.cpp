
#include "Stack.h"
#define N_OPTR 9 //运算符总数
const char pri[N_OPTR][N_OPTR] = {
    //运算符优先等级 [栈顶] [当前]
    /* |------------------- 当前运算符 ------------------| */
    /*          +    -    *    /    ^    !    (    )   \0 */
    /* -- + */ '>', '>', '<', '<', '<', '<', '<', '>', '>',
    /* |  - */ '>', '>', '<', '<', '<', '<', '<', '>', '>',
    /* 栈 * */ '>', '>', '>', '>', '<', '<', '<', '>', '>',
    /* 顶 / */ '>', '>', '>', '>', '<', '<', '<', '>', '>',
    /* 运 ^ */ '>', '>', '>', '>', '>', '<', '<', '>', '>',
    /* 算 ! */ '>', '>', '>', '>', '>', '>', ' ', '>', '>',
    /* 符 ( */ '<', '<', '<', '<', '<', '<', '<', '=', ' ',
    /* |  ) */ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
    /* - \0 */ '<', '<', '<', '<', '<', '<', '<', ' ', '='};

float evalute(char *S, char *&RPN)
{

    Stack<float> opnd;    //运算数栈
    Stack<char> optr;     //运算符栈
    optr.push('\0');      //尾哨兵先入栈
    while (!optr.empty()) //逐个处理各字符，直到运算符栈空
    {
        if (isdigit(*S)) //若是操作数
        {
            readNumber(S, opnd);     //读入操作数
            append(RPN, opnd.top()); //将其接至RPN末尾
        }
        else //若是运算符
            switch (orderBetween(optr.top(), *S))
            {
            //视其与栈顶运算符之间的优先级高低分别处理
            case '<':          //栈顶运算符优先级更低
                optr.push(*S); //计算推迟，当前运算符进栈
                S++;           //将字符地址移至下一位
                break;
            case '=':       //优先级相等
                            //(左右括号相遇，这时括号内已经计算完成，删去括号即可)
                optr.pop(); //脱括号并接收下一个字符
                S++;
                break;
            case '>': //栈顶运算符优先级更高
                //实施相应运算并将结果重新入栈
            {                         //case中定义变量的情况下要加花括号
                char op = optr.pop(); //栈顶运算符出栈
                append(RPN, op);      //将其接至RPN末尾
                if (op == '!')        //若是一元运算符(仅有！是)
                {
                    float pOpnd = opnd.pop();    //取出一个操作数
                    opnd.push(calcu(op, pOpnd)); //操作数与操作符实施一元计算，结果入栈
                }
                else //其他情况即二元运算符
                {
                    //执行这里的操作符时我们实际上已经扫描过了下一个操作符
                    //这意味着这个二元操作符两侧的操作数都已入栈
                    //取出这两个操作数
                    float pOpnd2 = opnd.pop(), pOpnd1 = opnd.pop();
                    opnd.push(calcu(pOpnd1, op, pOpnd2)); //实施一元运算并将结果入栈
                }
                break;
            }
            default:
                exit(-1); //其他情况为语法错误，直接退出
            }             //switch
    }                     //while
    return opnd.pop();    //弹出并返回最后的计算结果
}
