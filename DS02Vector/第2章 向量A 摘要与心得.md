# 第2章 向量A

- **数据结构**是数据项的结构化集合

- 结构性表现为数据项之间的相互联系及作用，即定义于数据项之间的某种逻辑次序

- 根据这种逻辑次序，将数据结构划分为三类

  - **线性结构**，最为基本的线性结构统称为**序列sequence**，根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，将其分为

    1. **==向量vector==** 所有数据项的物理存放位置与其逻辑次序完全吻合，此时的逻辑次序也称作秩（rank）

    2. **==列表list==**       逻辑上相邻的数据项在物理上未必相邻，而是采用间接定址的方式通过封装后的位置（position）相互引用

  - **半线性结构**

  - **非线性结构**

## 2.1 从数组到向量

### 2.1.1 数组

数组元素与编号一一对应，A[0], A[1], A[2], A[3], ... , A[n-1]，它们存放于起始于地址A、物理位置连续的一段存储空间，并统称作数组（array），若数组A[ ]存放空间的起始地址为A，且每个元素占用s个单位的空间，则元素A[i]对应的物理地址为：**A + i * s**

> 对于任何0 <= i < j < n，A[ i ]都是A[ j ]的**前驱（predecessor）**，A[ j ]都是A[ i ]的**后继（successor）**，特别的，A[ i ]与A[ j ]紧邻时，称作**直接前驱intermediate predecessor**和**直接后继intermediate successor**。
>
> 任一元素的所有前驱构成其**前缀prefix**，所有后继构成其**后缀suffix**

### 2.1.2 向量

向量是线性数组的一种抽象和泛化，它也是由具有线性次序的一组元素构成的集合V = {v<sub>0</sub>, v<sub>1</sub>, ..., v<sub>n-1</sub>}，**各元素与[0, n)内的秩Rank一一对应**，这种访问方式称作**循秩访问**

```cpp
typedef int Rank;
```

向量的优点是：操作，管理维护更加简化统一和安全；元素类型可以灵活选取，便于定做复杂的数据结构。

## 2.2 接口

### 2.2.1 ADT接口

| 操作接口        | 功能                                                         | 适用对象 |
| --------------- | ------------------------------------------------------------ | -------- |
| `size()`        | 报告向量当前的规模（元素总数）**有返回值**                   | 向量     |
| `get(r)`        | 获取秩为r的元素  **有返回值**                                | 向量     |
| `put(r, e)`     | 用e替换秩为r的元素   **无返回值**                            | 向量     |
| `insert(r, e)`  | e作为秩为r的元素插入，原后继元素依次后移  **无返回值**       | 向量     |
| `remove(r)`     | 删除秩为r的元素，返回该元素中原存放的对象  **有返回值**      | 向量     |
| `disordered()`  | 判断所有元素是否已按非降序排列 ，返回逆序数（为0时则已排好）  **有返回值** | 向量     |
| `sort()`        | 调整各元素的位置，使之按非降序排列  **无返回值**             | 向量     |
| `find(e)`       | 查找等于e且秩最大的元素，找不到等于e的元素时返回-1  **有返回值** | 向量     |
| `search(e)`     | 查找目标元素e，返回**不大于e**且秩最大的元素  **有返回值**   | 有序向量 |
| `deduplicate()` | 剔除重复元素                                                 | 向量     |
| `uniquify()`    | 剔除重复元素                                                 | 有序向量 |
| `traverse()`    | 遍历向量并统一处理所有元素，处理方法由函数对象指定           | 向量     |

### 2.2.2 vector模板类

```cpp
//代码2-1
typedef int Rank;
template <typename T>
class Vector
{
private:
    Rank _size;    //规模
    int _capacity; //容量
    T *_elem;      //数据存储区域
protected:
    /*内部函数*/
public:
    /*构造函数*/
    /*析构函数*/
    /*只读接口*/
    /*可写接口*/
    /*遍历接口*/
};
```

![image-20200809175858300](https://i.loli.net/2020/08/21/CxOoPd7SsUribN4.png)

## 2.3 构造和析构

由代码2-1可知，向量结构在内部维护一个元素类型为T的私有数组`_elem[]`：其容量由私有变量`_capacity`指示；有效元素的数量（即向量当前的实际规模），则由`_size`指示，我们进一步对**向量元素的rank**、**数组单元的逻辑编号**以及**物理地址之间**的关系做以下约定：

==**向量中秩为r的元素，对应于内部数组中的`_elem[r]`，其物理地址为`_elem + r`**==

> 这里的r前为何没有×单个元素的大小，都按1看待？数组`_elem`的首元素地址加r代表`_elem[r]`的地址

### 2.3.1 默认构造方法

```cpp
//代码2-2
#define DEFAULT_CAPACITY 3	//默认初始容量（根据实际应用调整）
Vector(int c = DEFAULT_CAPACITY) //默认
{
    _elem = new T[_capacity = c];
    _size = 0;
}
```

![image-20200809175826359](https://i.loli.net/2020/08/21/zZKD1yNcTQJBqg5.png)根据创建者指定的初始容量，向系统申请空间（如果未指定，则采用默认容量`DEFAULT_CAPACITY`），以创建内部私有数组`_elem[]`，因为初生的向量不含任何元素，将表示规模（有效元素个数）的`_size`初始化为0

#### 复杂度分析

整个过程顺序进行，没有任何迭代，故若忽略用于分配数组空间的时间，共需常数时间**O(1)**。

### 2.3.2 基于复制的构造方法

向量另一种常用的创建方式是以某个已有的向量或数组为蓝本，进行（局部或整体的）克隆。

```cpp
//代码2-3
template <typename T> //元素类型
//以数组区间A[lo, hi)为蓝本复制向量,注意左闭右开，hi作为一个哨兵
void Vector<T>::copyFrom(T const *A, Rank lo, Rank hi)
{
    _elem = new T[_capacity = 2 * (hi - lo)]; //分配空间，为何是两倍？见2.4
    _size = 0;                                //规模清零
    while (lo < hi)                           //A[lo, hi)中的元素逐一
        _elem[_size++] = A[lo++];             //复制到_elem[0, hi - lo)
}
```

`copyFrom()`首先根据待复制区间的边界，换算出新向量的初始规模；再以双倍的容量，为内部数组`_elem[]`申请空间。最后通过一趟迭代，完成区间**`A[lo,  hi)`**内各元素的顺次复制。

#### 复杂度分析

若忽略开辟新空间所需的时间，运行时间应正比于区间宽度，即**O(hi - lo) = O(_size)**。

---

下面是具体的构造函数：

```cpp
//代码2-4
public:
    /*构造函数*/
    Vector(int c = DEFAULT_CAPACITY) //默认
    {
        _elem = new T[_capacity = c];
        _size = 0;
    }

    Vector(T const *A, Rank lo, Rank hi) //数组区间复制
    {
        copyFrom(A, lo, hi);
    }

    Vector(Vector<T> const &V, Rank lo, Rank hi) //向量区间复制
    {
        copyFrom(V._elem, lo, hi);
    }

    Vector(Vector<T> const &V) //向量整体复制
    {
        copyFrom(V._elem, 0, V._size);
    }
```

---

需要强调一点：由于向量内部含有动态分配的空间，默认的运算符“=”不足以支持向量之间的直接赋值。为了实现这个目的，我们重载向量的赋值运算符。

```cpp
//代码2-5
template <typename T>
Vector<T>& Vector<T>::operator=(Vector<T> const &V) //重载赋值运算符
{
    if (_elem)
        delete[] _elem;             //释放原内容
    copyFrom(V._elem, 0, V.size()); //整体复制
    return *this;                   //返回当前对象的引用，以便链式赋值
}
```



### 2.3.3 析构方法

```cpp
//代码2-6 
~Vector() //释放内部空间
{
	delete[] _elem;
}
```

不再需要使用的向量对象应该借助析构函数及时清理释放系统资源，同一个对象只能有一个析构函数且不能重载。

如代码所示，我们只需释放存放元素的内部数组`_elem[]`，而`_capacity`，`_size`这类内部变量无需做任何处理，将作为向量对象的一部分被系统回收。

#### 复杂度分析

不计系统用于空间回收的时间，这个析构过程需要的时间为**O(1)**

## 2.4 动态内存管理

### 2.4.1 静态空间管理

内部数组所占物理空间的容量在向量生命期内不允许调整，这样的管理策略难以保证空间效率。

**向量实际规模与其内部数组容量的比值 = `_size / _capacity`，称之为装填因子**，它是衡量空间利用率的重要指标。

我们下面讨论的目的就是找到方法==**保证向量的装填因子<1，而又不接近于0**==

### 2.4.2 可扩充向量

若内部数组仍有空余，则操作可照常执行。每经一次插入（删除），可用空间都会减少（增加）一个单元。一旦可用空间耗尽，就动态地扩大内部数组的容量（一种实现方法是，申请一个更大容量的数组，将原数组中的成员复制到新数组，然后将原数组释放）。

![image-20200809181440905](https://i.loli.net/2020/08/21/oODJ7ibpcIay1fw.png)

### 2.4.3 扩容

```cpp
//代码2-7
template <typename T>
void Vector<T>::expend() //向量空间不足时扩容
{
    if (_size < _capacity) //尚未满员时，不必扩容
        return;
    if (_capacity < DEFAULT_CAPACITY)
        _capacity = DEFAULT_CAPACITY; //不低于最小容量
    T *oldElem = _elem;
    _elem = new T[_capacity <<= 1]; //容量加倍
    for (int i = 0; i < _size; i++)
        _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型或者‘=’是已重载赋值操作符）
    delete[] oldElem;          //释放原空间
}
```

每次调用`insert()`接口插入新元素时，都有先调用该算法，检查内部数组的可用容量，一旦当前数据区已满（`_size = _capacity`），则将原数组替换为一个更大的数组。

这里的关键问题是：为何容量要加倍而不是以其他数目增加？

### 2.4.4 分摊分析

#### 时间代价

这种扩容方式的灵活性不是没有代价的，每次扩容发生的元素搬迁都需要额外的时间，即每次n➡2n的扩容都需要花费**O(2n) = O(n)**时间，这也是最坏情况下，单次插入操作所需的时间。

随着向量规模的不断扩大，在执行插入操作之前需要进行扩容的概率，也将迅速降低。故就某种平均意义而言，用于扩容的时间成本不至很高。以下不妨就此做一严格的分析。

#### 分摊复杂度

不妨考查对可扩充向量的足够多次连续操作，并将其间所消耗的时间，分摊至所有的操作。如此分摊平均至单次操作的时间成本，称作**分摊运行时间**（amortized running time）。

以可扩充向量为例，可以考查对该结构的连续n次（查询、插入或删除等）操作，将所有操作中用于内部数组扩容的时间累计起来，然后除以n。*只要n足够大，这一平均时间就是用于扩容处理的分摊时间成本。*

下面我们来推导可扩充向量单次操作中，用于扩容处理的分摊时间成本：

最坏情况：在初始容量1的满向量中，连续插入**n = 2<sup>m</sup> >> 2**	个元素，共扩容了m（即log<sub>2</sub>n）次

![image-20200809225609339](https://i.loli.net/2020/08/21/tBd8VDZHYclQsSI.png)

每次扩容所需要的时间成本：**1， 2， 4， 8，... , 2<sup>m</sup>**，*理解一点，插入第2<sup>m</sup>个元素时恰好发生扩容，复制这2<sup>m</sup>个元素消耗的时间为2<sup>m</sup>，扩容后的容量为2<sup>m+1</sup>在图中未标出，但2<sup>m</sup>这个时间成本不能忽略。*

作为几何级数，各次扩容的时间成本相加后与末项同阶，**总体耗时为T(n) = O(2<sup>m</sup>) = O(n)**

由代码2-7可知，每次插入操作我们都要调用`expend()`，故**每次操作的分摊成本为T(n) / n = O(1)**

#### 其他扩容策略

假如我们采用递增的扩容策略，下面简要推算这种方式的分摊运行时间

最坏情况：在初始容量0的空向量中，连续插入**n = m*i >> 2**	个元素，每次扩容 i 个元素共扩容了m次

![image-20200809232117948](https://i.loli.net/2020/08/21/HJLlGvfXd1zIFiC.png)

每次扩容复制原向量所需要的时间成本：0, i, 2i, ... , (m-1) × i，m × i

作为算术级数，各次扩容的时间成本相加后是末项的平方，总体耗时为T(n) = O((m × i)<sup>2</sup>) = O(n<sup>2</sup>),每次操作的分摊成本为T(n) / n = O(n)。

由此可见，在时间成本上，倍增策略优于递增策略。

### 2.4.5 缩容(见代码shrink函数)

## 2.5 常规(无序)向量

无序向量：T为**可判等**的基本类型，或已重载操作符“`==`”或“`!=`”

有序向量：T为**可比较**的基本类型，或已重载操作符“`<`”或“`>`”

### 2.5.1 使用`[]`直接引用元素

与数组通过下标访问元素的方式相比(`A[i]`)，向量ADT设置的`get()`和`put()`接口显得不那么直观自然，通过重载操作符`[]`来解决这个问题。

调用下面的函数，则`V[r]`只能作右值，引用的`vector<T>`对象不能修改（后一个`const`），返回的值也不能立即修改（前一个`const`）。

```cpp
template <typename T>
const Vector<T> &Vector<T>::operator[](Rank r) const //重载下标运算符
{
    return _elem[r];
    // assert: 0 <= r < _size
}
```

当然，重载下面函数，`V[r]`可以作为左值被修改。

```cpp
template <typename T>
T &Vector<T>::operator[](Rank r) //重载下标运算符
{
    return _elem[r];
    // assert: 0 <= r < _size
}
```

注意，我们这里（及后面的各种算法）没有对r的范围进行判断而是断言`0 <= r < _size`，实际应用中不能这样。

### 2.5.2 置乱器(见代码unsort函数)

### 2.5.3 判等器与比较器

### 2.5.4 无序查找

#### 实现

```cpp
//无序向量的顺序查找
template <typename T>
Rank Vector<T>::find(T const &e, Rank lo, Rank hi) const
{
    while ((lo < hi--) && (e != _elem(hi))) //从后向前顺序查找
        return hi;                          // 如果hi < lo，则说明查找失败；否则hi就是命中元素的Rank
}
```

#### 复杂度分析

最坏情况下，**O(hi - lo) = O(n)**；最好情况下，**O(1)**

对于规模相同、内部组成不同的输入，渐进运行时间却有本质区别，故此类算法也称作**输入敏感input sensitive算法**。

### 2.5.5 插入`insert(r, e)`

#### 实现

```cpp
template <typename T>
Rank Vector<T>::insert(Rank r, T const &e)
{
    expand();                       //如有必要则扩容
    for (int i = _size; i > r; i--) //自后向前
        _elem[i] = _elem[i - 1];    //将后继元素顺次后移一个单元
    _elem[r] = e;                   //置入新元素
    _size++;                        //更新规模
    return r;                       //返回秩
}
```

记得判断是否扩容☑

记得使元素按由后至前的顺序向后移位（由前至后会发生覆盖）☑

#### 复杂度分析

时间成本主要来自后继元素的后移，线性正比于后缀长度，**O(_size - r + 1)**

最好的情况，`r = _size`, O(1)的时间；最坏的情况，`r = 0`，O(_size)的时间。

> 对于每个插入位置而言，对应的移动操作次数恰好等于其后继元素（包含自身）的数目。不难看出它们也构成一个等差数列，故在等概率的假设条件下，其均值（数学期望）应渐进地与其中的最高项同阶，为**O(n)**，n为向量规模

### 2.5.6 删除

#### 实现

```cpp
//区间删除
template <typename T>
int Vector<T>::remove(Rank lo, Rank hi)
{
    if (lo == hi) //出于对效率的考虑，单独处理退化情况
        return 0;
    while (hi < _size)
        _elem[lo++] = _elem[hi++]; //[hi,_size)顺次前移hi-lo个单位
    _size = lo;                    //更新规模，这里的lo经过循环更新后就等于当前规模
    shrink();                      //如有必要，进行缩容
    return hi - lo;                //返回被删除元素数目
}

//单元素删除
template <typename T>
T Vector<T>::remove(Rank r)
{
    T e = _elem[r];   //备份被删除元素
    remove(r, r + 1); //等效对区间[r, r+1)的删除
    return e;         //返回被删除元素
}
```

![image-20200812094231805](https://i.loli.net/2020/08/21/Xs7Pq21ZybtUKH5.png)

#### 复杂度分析

计算成本主要来自于**后缀元素的前移**，**O(m+1) = O(_size - hi + 1)**，与要删除的元素的规模无关

最好的情况，`hi`在最后一个，O(1);最坏的情况，`hi`在第一个，O(n) = O(_size)

还有一种实现方法是通过反复调用`remove(r)`实现`remove(lo, hi)`，但是这么做后发生多次后缀元素的前移，每次循环耗时正比于后缀长度，循环次数等于区间宽度`hi - lo`，复杂度可能高至O(n<sup>2</sup>)

### 2.5.7 唯一化

鳯兮鳯兮，故是一鳯

#### 实现

```cpp
template <typename T>
int Vector<T>::deduplicate()
{
    int oldSize = _size;                        //记录原规模
    Rank i = 1;                                 //从_elem[1]开始
    while (i < _size)                           //自前向后逐一考察各元素
        (find(_elem[i], 0, i) < 0) ?            //前缀中是否存在雷同者
            i++                                 //不存在-继续查找下一个元素；
                                   : remove(i); //存在-删除该元素
    return oldSize - _size;                     //返回向量规模变化量，即删除元素数
}
```

#### 正确性分析

不变性：在while循环中，在当前元素`_elem[i]`的前缀`_elem[0, i)`内，所有元素彼此互异

单调性：随着反复while的迭代，当前前缀的长度单调非降，直到达到`size`；对称的后缀长度单调下降，直到0

#### 复杂度分析

由程序可知，经过n -2 步迭代后，算法必然终止，每步迭代主要的计算成本来自`find()`和`remove()`两个接口。

`_elem[i]`，对于`find()`，查找范围是`[0, i)`，对于`remove()`（不一定调用），后缀规模是`(i, size)`；两者相加，每轮迭代的时间复杂度最大为O(n)

故总体复杂度为**O(n - 2) * O(n) = O(n<sup>2</sup>)**

###  2.5.8 遍历

#### 实现

```cpp
template <typename T>
void Vector<T>::traverse(void (*visit)(T &)) //函数指针，只读或局部性修改
{
    for (int i = 0; i < _size; i++)
        visit(_elem[i]);
}

template <typename T>
template <typename VST>
void Vector<T>::traverse(VST &visit) //函数对象，全局性修改更便捷
{
    for (int i = 0; i < _size; i++)
        visit(_elem[i]);
}
```

传入的参数是函数指针或函数对象，遍历时，循环调用这个函数，一般建议使用函数对象

使用函数对象时，必须其中重载操作符`()`，即`operator()(){...}`

#### 实例

```cpp
template <typename T>
struct Increase //函数对象，递增一个T类函数，通过重载操作符()实现
{
    virtual void operator()(T &e)
    {
        e++; //假设T可以直接递增或已重载++
    }
};

template <typename T>
void increase(Vector<T> &V) //统一递增向量中的各元素
{
    V.traverse(Increase<T>());
}
```

#### 复杂度分析

遍历操作本身只包含一层线性的循环迭代，故除了向量规模的因素之外，遍历所需时间应线性正比于所统一指定的基本操作所需的时间。比如在上例中，统一的基本操作`Increase<T>()`只需常数时间，故这一遍历的总体时间复杂度为O(n)。

## 2.6 有序向量

### 2.6.1比较器

### 2.6.2 有序性甄别

### 2.6.3 唯一化

### 2.6.4 查找

### 2.6.5 二分查找(版本A)

### 2.6.6 Fibonacci查找

### 2.6.7 二分查找(版本B)

### 2.6.8 二分查找(版本C)

## 2.7 排序与下界

## 2.8 排序器

