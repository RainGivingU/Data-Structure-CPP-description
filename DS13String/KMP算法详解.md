# KMP算法详解

## 1. KMP简介及相关基本概念

![image-20201028194453944](https://i.loli.net/2020/11/07/SgNUlyEXhx9jRer.png)

KMP算法是上图中的三位大牛共同提出的一种解决字符串匹配问题的算法，我们先了解一下什么是字符串匹配问题

字符串匹配问题：给定我们两个字符串，分别是文本串`T`和模式串`P`，判断`T`中是否存在子串和`P`相同，若存在，返回该子串的位置。例如：

![image-20201107093658753](C:%5CUsers%5CspringmorningQ%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201107093658753.png)

我们发现`T`的子串`T[5, 8]`和模式串`P`匹配，因此返回`5`（用子串第一个字符的位置指代这个子串的位置）

下面的过程中，我们默认文本串`T`的长度为**n**，模式串`P`的长度为**m**，而且**n**远大于**m**，这很符合该算法在各种识别场合下的应用

## 2. 朴素的想法：蛮力匹配(BF)

在介绍KMP之前我们可以先试着自己设计解决这个问题的算法，大部分人的想法可能都比较"朴素"，那就是我们先把模式串`P`和文本串`T`在开头处对齐

![image-20201107095432131](C:%5CUsers%5CspringmorningQ%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20201107095432131.png)

然后将`T`和`P`的对齐部分逐个比对

![image-20201107095825791](https://i.loli.net/2020/11/07/G3ovAW5h2DUCBsd.png)

发现不匹配`T[4] != P[4]`了怎么办？把`P`向后移一个单位，咱们又可以继续了！

![image-20201107100509955](https://i.loli.net/2020/11/07/x4Nd5a76GpRQKMe.png)

根据给出的`P`和`T`我们不难发现，在`P[4]`和`T[14]`对齐前，必然是每次比对到`P[4]`时都会因为不匹配而导致模式串向后移一个单位，然后再对齐，.....

![image-20201107103938629](https://i.loli.net/2020/11/07/n7fr6ANyWtsPHld.png)

最后的最后，我们的模式串`P`在`T[10, 14]`找到了自己的归宿，返回`10`，蛮力匹配算法执行结束

当然，上面的例子是最极端的情况，每次都是在比对到模式串`P`最后一个字符才发现失配（=前面的比对前功尽弃），而且正确答案在文本串`T`的末尾（=一点懒都偷不得），我们对时间复杂度的计算正应该基于这种情况

### 蛮力匹配的时间复杂度

由上例我们发现，每一轮比对的次数等于模式串`P`的长度**m**，第一轮`P`和`T`对齐的位置是是`T[0]`，最后一轮对齐的位置是`T[n - m]`，`0`到`n - m`一共进行了`n - m + 1`轮，**O(m) * O(n - m + 1) = O(m*n)**

### C++实现

KMP算法实际上就是由蛮力算法优化而来，我们可以在后面看到，两者具体实现的代码有很大的相似性。实现方法有很多，掌握算法思想是关键。

```cpp
int BF(char *P, char *T)
{
    size_t n = strlen(T), i = 0;
    size_t m = strlen(P), j = 0;
    while (j < m && i < n) //自左向右逐个比对字符
    {
        if (T[i] == P[j]) //若匹配
        {
            ++i; //则转到下一对字符
            ++j;
        }
        else //否则
        {
            //T回退到上一次和P比对的初始位置的下一位置
            i -= j - 1;
            j = 0; //P复位
        }
    }
    return i - j;
}
```

>  **循环结束条件与返回值**

>  不满足`j < m`：对应于模式串P得到了整体的匹配（ 实际`j`就记录了本轮匹配中成功比对次数），此时返回的`i - j`就对应T中这个子串的开始位置

> 不满足`i < n`：此时`i`必然恰好为`n`，而`j`尚处于合法区间`j < m `，那么返回的`i - j > n - m` (我们知道，当P恰好与T末尾的长度为m的子串匹配时，`i - j = n - m`为最大值)，据此判断没有找到匹配的子串

### 反思

我们发现蛮力匹配的算法复杂度**O(n * m)**很难令人满足，是什么造成了这种算法的低效呢？

假设一轮比对在`P[j] != T[i]`发生了失配，那么我们一定可得`P[0, j - 1]`部分和`T[i - j, i - 1]`部分是完全相同的

![image-20201107111537049](https://i.loli.net/2020/11/07/7huserZK2zDpyXO.png)

既然我们已经得知了`T[i - j, i - 1]`的内容，那么就可以想办法利用这一信息，调整下一轮对齐的位置，尽量减少比对的次数，例如

![image-20201107112741098](https://i.loli.net/2020/11/07/16jlx9CLGhVPUKJ.png)

我们已经知道上一轮和`P`对齐的有`REGR`，那么本轮移动时就不必和`E` `G`进行对齐了（因为不可能匹配）直接向后移动3个单位和`R`对齐即可。

## 3. KMP主体框架

KMP算法相比于BF算法最大的提升就是它可以快速移动而非像BF那样只能一步一步的爬行，快速移动的依据是KMP的核心——**next表**，通过查表，我们可以得到发生失配时`P`要向后移动的位置（即每个`j`都有一个对应的`next[j]`，下面常写作`t`），而非BF中的固定向后移动一个位置，这也是两者最大的区别（除此之外，还有`if`语句增加了并列条件，这也和next表的设定有关）

### C++实现

```cpp
int KMP(char *P, char *T)
{
    int *next = buildNext(P);      //构造next表
    int n = (int)strlen(T), i = 0; //文本串指针
    int m = (int)strlen(P), j = 0; //模式串指针
    while (j < m && i < n)
        if (j < 0 || T[i] == P[j]) //若匹配
        {
            //携手共进
            ++i;
            ++j;
        }
        else             //若失配
            j = next[j]; //P查表右移，T不动
    delete[] next;
    return i - j;
}
```

特别地，若在`j = 0`时就发生了失配，我们令`next[0] = -1`（假想存在`P[-1]`这个哨兵，它和任何字符都匹配），并在`if`语句中将这种情况和成功比对等价，随后`++j; ++i;`相当于使模式串向右移动一个单位开始下一轮比对

## 4. 理解next[]表

发生一次失配`T[i] != P[j]`

此时P的前缀是`T[0, j - 1]`，P和T比对过(完全相同)的前缀是`P[i - j, i - 1]`

![image-20201107111537049](https://i.loli.net/2020/11/07/7wVUXhCJqL4lnDt.png)

查询`next[]`表，将`P[t]`与`T[i]`对齐开始比对，`P[t]`的前缀是`P[0, t - 1]`（黄色荧光笔标记），这个前缀就是我们KMP快速移动所要跳过（不再比对）的部分，它对应T中的`T[i - t, i - 1]`（黄色荧光笔标记），对应未移动`P`中的`P[j - t, j - 1]`。

![image-20201107152852645](https://i.loli.net/2020/11/07/l3wpQbTMZWczsgi.png)

既然是无须比对的部分，必然有**`P[0, t - 1] == T[i - t, i - 1]`**，而且我们还知道**`T[i - t, i - 1] == P[j - t, j - 1]`**（这就是我们上轮比对储存的信息发挥了作用！），那么**`P[0, t - 1] == P[j - t, j - 1]`**即可！

发现了吗，`P`中每个位置`P[j]`比对失配后要和`T[i]`对齐的位置`P[t]`其实和`T`没有一毛钱关系，只需满足`P[0, t - 1] == P[j - t, j - 1]`即可，这意味着我们的**next表**只需根据P进行构造即可

请注意绿色荧光笔标记的两部分即**`P[0, t - 1]`和`P[j - t, j - 1]`**，易知，它们分别是**字符串`P[0, j - 1]`的真前缀和真后缀**，这两部分相等，我们称之为自匹配

由图容易发现，每次根据next表向后移动的位移量为`j - t`，为了确保跳过对比的字符串确实都是无需比对的，我们在`j`对应多个`t`时只取最大的`t`放入next表

总结一下，**next表就是记录了`P[0, j - 1]`中前`t`个字符和后`t`个字符恰好相等的最大值`t = next[j]`**

## 5. 构造next[]表

### 递推：由next[j] -> next[j + 1]

如果我们已知`next[j] = t`，则`P[0, j)`中，自匹配的真前缀（子串A）和真后缀（子串B）的最大长度为`t`

![image-20201107190625581](https://i.loli.net/2020/11/07/kqxhMrEN5cfaQb2.png)

由图，如果恰好`P[t] == P[j]`（即图中X == Y），那么在`P[0, j + 1)`中自匹配的真前缀和真后缀最大长度较`P[0, j)`的+1，即`next[j + 1] == t + 1`

如果`P[j] != P[t]`（即图中X != Y）怎么办？

此时以`子串A+X`和`子串B+Y`作`P[0, j + 1)`的真前缀和真后缀显然已经行不通，我们要缩短寻找的真前缀和真后缀的长度

而**真前缀一定在子串A中，真后缀一定在子串B中**，**子串A和子串B相等，相当于同一个字符串**，该字符串`P[0, next[j]]`的最大真前缀和真后缀长度是`next[next[j]]`，令`t = next[next[j]]`，继续判断`P[t]`是否等于`P[j]`，等于则`next[j + 1] = t + 1`，否则`t = next[t]`；再判断......

### C++实现

```cpp
int *buildNext(char *P) //构造next表
{
    int m = (int)strlen(P), j = 0; //“主”串指针
    int *N = new int[m];           //next表
    int t = N[0] = -1;             //模式串指针
    while (j < m - 1)
    {
        //匹配 or 不匹配
        (t < 0 || P[j] == P[t]) ? N[++j] = ++t : t = N[t];
    }
    return N;
}
```

